## 模板

这里主要存放了一些算法竞赛中较复杂算法的模板。如果有觉得很好的模板可以提 issue。

### 计算几何

使用泛型编写，必要时可以将数据范围更改为 ```long long```，谨防计算几何丢失精度。

作者：俊杰 Charles。

```cpp
#include <bits/stdc++.h>
using namespace std;

using point_t = long double; //全局数据类型，可修改为 long long 等

constexpr point_t eps = 1e-8;
constexpr long double PI = 3.1415926535897932384l;

// 点与向量
template <typename T>
struct point
{
	T x, y;

	bool operator==(const point &a) const { return (abs(x - a.x) <= eps && abs(y - a.y) <= eps); }
	bool operator<(const point &a) const
	{
		if (abs(x - a.x) <= eps)
			return y < a.y - eps;
		return x < a.x - eps;
	}
	bool operator>(const point &a) const { return !(*this < a || *this == a); }
	point operator+(const point &a) const { return {x + a.x, y + a.y}; }
	point operator-(const point &a) const { return {x - a.x, y - a.y}; }
	point operator-() const { return {-x, -y}; }
	point operator*(const T k) const { return {k * x, k * y}; }
	point operator/(const T k) const { return {x / k, y / k}; }
	T operator*(const point &a) const { return x * a.x + y * a.y; } // 点积
	T operator^(const point &a) const { return x * a.y - y * a.x; } // 叉积，注意优先级
	int toleft(const point &a) const
	{
		const auto t = (*this) ^ a;
		return (t > eps) - (t < -eps);
	}															  // to-left 测试
	T len2() const { return (*this) * (*this); }				  // 向量长度的平方
	T dis2(const point &a) const { return (a - (*this)).len2(); } // 两点距离的平方

	// 涉及浮点数
	long double len() const { return sqrtl(len2()); }																	   // 向量长度
	long double dis(const point &a) const { return sqrtl(dis2(a)); }													   // 两点距离
	long double ang(const point &a) const { return acosl(max(-1.0l, min(1.0l, ((*this) * a) / (len() * a.len())))); }	   // 向量夹角
	point rot(const long double rad) const { return {x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad)}; }		   // 逆时针旋转（给定角度）
	point rot(const long double cosr, const long double sinr) const { return {x * cosr - y * sinr, x * sinr + y * cosr}; } // 逆时针旋转（给定角度的正弦与余弦）
};

using Point = point<point_t>;

// 极角排序
struct argcmp
{
	bool operator()(const Point &a, const Point &b) const
	{
		const auto quad = [](const Point &a)
		{
			if (a.y < -eps)
				return 1;
			if (a.y > eps)
				return 4;
			if (a.x < -eps)
				return 5;
			if (a.x > eps)
				return 3;
			return 2;
		};
		const int qa = quad(a), qb = quad(b);
		if (qa != qb)
			return qa < qb;
		const auto t = a ^ b;
		// if (abs(t)<=eps) return a*a<b*b-eps;  // 不同长度的向量需要分开
		return t > eps;
	}
};

// 直线
template <typename T>
struct line
{
	point<T> p, v; // p 为直线上一点，v 为方向向量

	bool operator==(const line &a) const { return v.toleft(a.v) == 0 && v.toleft(p - a.p) == 0; }
	int toleft(const point<T> &a) const { return v.toleft(a - p); } // to-left 测试
	bool operator<(const line &a) const								// 半平面交算法定义的排序
	{
		if (abs(v ^ a.v) <= eps && v * a.v >= -eps)
			return toleft(a.p) == -1;
		return argcmp()(v, a.v);
	}

	// 涉及浮点数
	point<T> inter(const line &a) const { return p + v * ((a.v ^ (p - a.p)) / (v ^ a.v)); } // 直线交点
	long double dis(const point<T> &a) const { return abs(v ^ (a - p)) / v.len(); }			// 点到直线距离
	point<T> proj(const point<T> &a) const { return p + v * ((v * (a - p)) / (v * v)); }	// 点在直线上的投影
};

using Line = line<point_t>;

//线段
template <typename T>
struct segment
{
	point<T> a, b;

	bool operator<(const segment &s) const { return make_pair(a, b) < make_pair(s.a, s.b); }

	// 判定性函数建议在整数域使用

	// 判断点是否在线段上
	// -1 点在线段端点 | 0 点不在线段上 | 1 点严格在线段上
	int is_on(const point<T> &p) const
	{
		if (p == a || p == b)
			return -1;
		return (p - a).toleft(p - b) == 0 && (p - a) * (p - b) < -eps;
	}

	// 判断线段直线是否相交
	// -1 直线经过线段端点 | 0 线段和直线不相交 | 1 线段和直线严格相交
	int is_inter(const line<T> &l) const
	{
		if (l.toleft(a) == 0 || l.toleft(b) == 0)
			return -1;
		return l.toleft(a) != l.toleft(b);
	}

	// 判断两线段是否相交
	// -1 在某一线段端点处相交 | 0 两线段不相交 | 1 两线段严格相交
	int is_inter(const segment<T> &s) const
	{
		if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b))
			return -1;
		const line<T> l{a, b - a}, ls{s.a, s.b - s.a};
		return l.toleft(s.a) * l.toleft(s.b) == -1 && ls.toleft(a) * ls.toleft(b) == -1;
	}

	// 点到线段距离
	long double dis(const point<T> &p) const
	{
		if ((p - a) * (b - a) < -eps || (p - b) * (a - b) < -eps)
			return min(p.dis(a), p.dis(b));
		const line<T> l{a, b - a};
		return l.dis(p);
	}

	// 两线段间距离
	long double dis(const segment<T> &s) const
	{
		if (is_inter(s))
			return 0;
		return min({dis(s.a), dis(s.b), s.dis(a), s.dis(b)});
	}
};

using Segment = segment<point_t>;

// 多边形
template <typename T>
struct polygon
{
	vector<point<T>> p; // 以逆时针顺序存储

	size_t nxt(const size_t i) const { return i == p.size() - 1 ? 0 : i + 1; }
	size_t pre(const size_t i) const { return i == 0 ? p.size() - 1 : i - 1; }

	// 回转数
	// 返回值第一项表示点是否在多边形边上
	// 对于狭义多边形，回转数为 0 表示点在多边形外，否则点在多边形内
	pair<bool, int> winding(const point<T> &a) const
	{
		int cnt = 0;
		for (size_t i = 0; i < p.size(); i++)
		{
			const point<T> u = p[i], v = p[nxt(i)];
			if (abs((a - u) ^ (a - v)) <= eps && (a - u) * (a - v) <= eps)
				return {true, 0};
			if (abs(u.y - v.y) <= eps)
				continue;
			const Line uv = {u, v - u};
			if (u.y < v.y - eps && uv.toleft(a) <= 0)
				continue;
			if (u.y > v.y + eps && uv.toleft(a) >= 0)
				continue;
			if (u.y < a.y - eps && v.y >= a.y - eps)
				cnt++;
			if (u.y >= a.y - eps && v.y < a.y - eps)
				cnt--;
		}
		return {false, cnt};
	}

	// 多边形面积的两倍
	// 可用于判断点的存储顺序是顺时针或逆时针
	T area() const
	{
		T sum = 0;
		for (size_t i = 0; i < p.size(); i++)
			sum += p[i] ^ p[nxt(i)];
		return sum;
	}

	// 多边形的周长
	long double circ() const
	{
		long double sum = 0;
		for (size_t i = 0; i < p.size(); i++)
			sum += p[i].dis(p[nxt(i)]);
		return sum;
	}
};

using Polygon = polygon<point_t>;

//凸多边形
template <typename T>
struct convex : polygon<T>
{
	// 闵可夫斯基和
	convex operator+(const convex &c) const
	{
		const auto &p = this->p;
		vector<Segment> e1(p.size()), e2(c.p.size()), edge(p.size() + c.p.size());
		vector<point<T>> res;
		res.reserve(p.size() + c.p.size());
		const auto cmp = [](const Segment &u, const Segment &v)
		{ return argcmp()(u.b - u.a, v.b - v.a); };
		for (size_t i = 0; i < p.size(); i++)
			e1[i] = {p[i], p[this->nxt(i)]};
		for (size_t i = 0; i < c.p.size(); i++)
			e2[i] = {c.p[i], c.p[c.nxt(i)]};
		rotate(e1.begin(), min_element(e1.begin(), e1.end(), cmp), e1.end());
		rotate(e2.begin(), min_element(e2.begin(), e2.end(), cmp), e2.end());
		merge(e1.begin(), e1.end(), e2.begin(), e2.end(), edge.begin(), cmp);
		const auto check = [](const vector<point<T>> &res, const point<T> &u)
		{
			const auto back1 = res.back(), back2 = *prev(res.end(), 2);
			return (back1 - back2).toleft(u - back1) == 0 && (back1 - back2) * (u - back1) >= -eps;
		};
		auto u = e1[0].a + e2[0].a;
		for (const auto &v : edge)
		{
			while (res.size() > 1 && check(res, u))
				res.pop_back();
			res.push_back(u);
			u = u + v.b - v.a;
		}
		if (res.size() > 1 && check(res, res[0]))
			res.pop_back();
		return {res};
	}

	// 旋转卡壳
	// func 为更新答案的函数，可以根据题目调整位置
	template <typename F>
	void rotcaliper(const F &func) const
	{
		const auto &p = this->p;
		const auto area = [](const point<T> &u, const point<T> &v, const point<T> &w)
		{ return (w - u) ^ (w - v); };
		for (size_t i = 0, j = 1; i < p.size(); i++)
		{
			const auto nxti = this->nxt(i);
			func(p[i], p[nxti], p[j]);
			while (area(p[this->nxt(j)], p[i], p[nxti]) >= area(p[j], p[i], p[nxti]))
			{
				j = this->nxt(j);
				func(p[i], p[nxti], p[j]);
			}
		}
	}

	// 凸多边形的直径的平方
	T diameter2() const
	{
		const auto &p = this->p;
		if (p.size() == 1)
			return 0;
		if (p.size() == 2)
			return p[0].dis2(p[1]);
		T ans = 0;
		auto func = [&](const point<T> &u, const point<T> &v, const point<T> &w)
		{ ans = max({ans, w.dis2(u), w.dis2(v)}); };
		rotcaliper(func);
		return ans;
	}

	// 判断点是否在凸多边形内
	// 复杂度 O(logn)
	// -1 点在多边形边上 | 0 点在多边形外 | 1 点在多边形内
	int is_in(const point<T> &a) const
	{
		const auto &p = this->p;
		if (p.size() == 1)
			return a == p[0] ? -1 : 0;
		if (p.size() == 2)
			return segment<T>{p[0], p[1]}.is_on(a) ? -1 : 0;
		if (a == p[0])
			return -1;
		if ((p[1] - p[0]).toleft(a - p[0]) == -1 || (p.back() - p[0]).toleft(a - p[0]) == 1)
			return 0;
		const auto cmp = [&](const Point &u, const Point &v)
		{ return (u - p[0]).toleft(v - p[0]) == 1; };
		const size_t i = lower_bound(p.begin() + 1, p.end(), a, cmp) - p.begin();
		if (i == 1)
			return segment<T>{p[0], p[i]}.is_on(a) ? -1 : 0;
		if (i == p.size() - 1 && segment<T>{p[0], p[i]}.is_on(a))
			return -1;
		if (segment<T>{p[i - 1], p[i]}.is_on(a))
			return -1;
		return (p[i] - p[i - 1]).toleft(a - p[i - 1]) > 0;
	}

	// 凸多边形关于某一方向的极点
	// 复杂度 O(logn)
	// 参考资料：https://codeforces.com/blog/entry/48868
	template <typename F>
	size_t extreme(const F &dir) const
	{
		const auto &p = this->p;
		const auto check = [&](const size_t i)
		{ return dir(p[i]).toleft(p[this->nxt(i)] - p[i]) >= 0; };
		const auto dir0 = dir(p[0]);
		const auto check0 = check(0);
		if (!check0 && check(p.size() - 1))
			return 0;
		const auto cmp = [&](const Point &v)
		{
			const size_t vi = &v - p.data();
			if (vi == 0)
				return 1;
			const auto checkv = check(vi);
			const auto t = dir0.toleft(v - p[0]);
			if (vi == 1 && checkv == check0 && t == 0)
				return 1;
			return checkv ^ (checkv == check0 && t <= 0);
		};
		return partition_point(p.begin(), p.end(), cmp) - p.begin();
	}

	// 过凸多边形外一点求凸多边形的切线，返回切点下标
	// 复杂度 O(logn)
	// 必须保证点在多边形外
	pair<size_t, size_t> tangent(const point<T> &a) const
	{
		const size_t i = extreme([&](const point<T> &u)
								 { return u - a; });
		const size_t j = extreme([&](const point<T> &u)
								 { return a - u; });
		return {i, j};
	}

	// 求平行于给定直线的凸多边形的切线，返回切点下标
	// 复杂度 O(logn)
	pair<size_t, size_t> tangent(const line<T> &a) const
	{
		const size_t i = extreme([&](...)
								 { return a.v; });
		const size_t j = extreme([&](...)
								 { return -a.v; });
		return {i, j};
	}
};

using Convex = convex<point_t>;

// 圆
struct Circle
{
	Point c;
	long double r;

	bool operator==(const Circle &a) const { return c == a.c && abs(r - a.r) <= eps; }
	long double circ() const { return 2 * PI * r; } // 周长
	long double area() const { return PI * r * r; } // 面积

	// 点与圆的关系
	// -1 圆上 | 0 圆外 | 1 圆内
	int is_in(const Point &p) const
	{
		const long double d = p.dis(c);
		return abs(d - r) <= eps ? -1 : d < r - eps;
	}

	// 直线与圆关系
	// 0 相离 | 1 相切 | 2 相交
	int relation(const Line &l) const
	{
		const long double d = l.dis(c);
		if (d > r + eps)
			return 0;
		if (abs(d - r) <= eps)
			return 1;
		return 2;
	}

	// 圆与圆关系
	// -1 相同 | 0 相离 | 1 外切 | 2 相交 | 3 内切 | 4 内含
	int relation(const Circle &a) const
	{
		if (*this == a)
			return -1;
		const long double d = c.dis(a.c);
		if (d > r + a.r + eps)
			return 0;
		if (abs(d - r - a.r) <= eps)
			return 1;
		if (abs(d - abs(r - a.r)) <= eps)
			return 3;
		if (d < abs(r - a.r) - eps)
			return 4;
		return 2;
	}

	// 直线与圆的交点
	vector<Point> inter(const Line &l) const
	{
		const long double d = l.dis(c);
		const Point p = l.proj(c);
		const int t = relation(l);
		if (t == 0)
			return vector<Point>();
		if (t == 1)
			return vector<Point>{p};
		const long double k = sqrt(r * r - d * d);
		return vector<Point>{p - (l.v / l.v.len()) * k, p + (l.v / l.v.len()) * k};
	}

	// 圆与圆交点
	vector<Point> inter(const Circle &a) const
	{
		const long double d = c.dis(a.c);
		const int t = relation(a);
		if (t == -1 || t == 0 || t == 4)
			return vector<Point>();
		Point e = a.c - c;
		e = e / e.len() * r;
		if (t == 1 || t == 3)
		{
			if (r * r + d * d - a.r * a.r >= -eps)
				return vector<Point>{c + e};
			return vector<Point>{c - e};
		}
		const long double costh = (r * r + d * d - a.r * a.r) / (2 * r * d), sinth = sqrt(1 - costh * costh);
		return vector<Point>{c + e.rot(costh, -sinth), c + e.rot(costh, sinth)};
	}

	// 圆与圆交面积
	long double inter_area(const Circle &a) const
	{
		const long double d = c.dis(a.c);
		const int t = relation(a);
		if (t == -1)
			return area();
		if (t < 2)
			return 0;
		if (t > 2)
			return min(area(), a.area());
		const long double costh1 = (r * r + d * d - a.r * a.r) / (2 * r * d), costh2 = (a.r * a.r + d * d - r * r) / (2 * a.r * d);
		const long double sinth1 = sqrt(1 - costh1 * costh1), sinth2 = sqrt(1 - costh2 * costh2);
		const long double th1 = acos(costh1), th2 = acos(costh2);
		return r * r * (th1 - costh1 * sinth1) + a.r * a.r * (th2 - costh2 * sinth2);
	}

	// 过圆外一点圆的切线
	vector<Line> tangent(const Point &a) const
	{
		const int t = is_in(a);
		if (t == 1)
			return vector<Line>();
		if (t == -1)
		{
			const Point v = {-(a - c).y, (a - c).x};
			return vector<Line>{{a, v}};
		}
		Point e = a - c;
		e = e / e.len() * r;
		const long double costh = r / c.dis(a), sinth = sqrt(1 - costh * costh);
		const Point t1 = c + e.rot(costh, -sinth), t2 = c + e.rot(costh, sinth);
		return vector<Line>{{a, t1 - a}, {a, t2 - a}};
	}

	// 两圆的公切线
	vector<Line> tangent(const Circle &a) const
	{
		const int t = relation(a);
		vector<Line> lines;
		if (t == -1 || t == 4)
			return lines;
		if (t == 1 || t == 3)
		{
			const Point p = inter(a)[0], v = {-(a.c - c).y, (a.c - c).x};
			lines.push_back({p, v});
		}
		const long double d = c.dis(a.c);
		const Point e = (a.c - c) / (a.c - c).len();
		if (t <= 2)
		{
			const long double costh = (r - a.r) / d, sinth = sqrt(1 - costh * costh);
			const Point d1 = e.rot(costh, -sinth), d2 = e.rot(costh, sinth);
			const Point u1 = c + d1 * r, u2 = c + d2 * r, v1 = a.c + d1 * a.r, v2 = a.c + d2 * a.r;
			lines.push_back({u1, v1 - u1});
			lines.push_back({u2, v2 - u2});
		}
		if (t == 0)
		{
			const long double costh = (r + a.r) / d, sinth = sqrt(1 - costh * costh);
			const Point d1 = e.rot(costh, -sinth), d2 = e.rot(costh, sinth);
			const Point u1 = c + d1 * r, u2 = c + d2 * r, v1 = a.c - d1 * a.r, v2 = a.c - d2 * a.r;
			lines.push_back({u1, v1 - u1});
			lines.push_back({u2, v2 - u2});
		}
		return lines;
	}

	// 圆的反演
	tuple<int, Circle, Line> inverse(const Line &l) const
	{
		const Circle null_c = {{0.0, 0.0}, 0.0};
		const Line null_l = {{0.0, 0.0}, {0.0, 0.0}};
		if (l.toleft(c) == 0)
			return {2, null_c, l};
		const Point v = l.toleft(c) == 1 ? Point{l.v.y, -l.v.x} : Point{-l.v.y, l.v.x};
		const long double d = r * r / l.dis(c);
		const Point p = c + v / v.len() * d;
		return {1, {(c + p) / 2, d / 2}, null_l};
	}

	tuple<int, Circle, Line> inverse(const Circle &a) const
	{
		const Circle null_c = {{0.0, 0.0}, 0.0};
		const Line null_l = {{0.0, 0.0}, {0.0, 0.0}};
		const Point v = a.c - c;
		if (a.is_in(c) == -1)
		{
			const long double d = r * r / (a.r + a.r);
			const Point p = c + v / v.len() * d;
			return {2, null_c, {p, {-v.y, v.x}}};
		}
		if (c == a.c)
			return {1, {c, r * r / a.r}, null_l};
		const long double d1 = r * r / (c.dis(a.c) - a.r), d2 = r * r / (c.dis(a.c) + a.r);
		const Point p = c + v / v.len() * d1, q = c + v / v.len() * d2;
		return {1, {(p + q) / 2, p.dis(q) / 2}, null_l};
	}
};

// 圆与多边形面积交
long double area_inter(const Circle &circ, const Polygon &poly)
{
	const auto cal = [](const Circle &circ, const Point &a, const Point &b)
	{
		if ((a - circ.c).toleft(b - circ.c) == 0)
			return 0.0l;
		const auto ina = circ.is_in(a), inb = circ.is_in(b);
		const Line ab = {a, b - a};
		if (ina && inb)
			return ((a - circ.c) ^ (b - circ.c)) / 2;
		if (ina && !inb)
		{
			const auto t = circ.inter(ab);
			const Point p = t.size() == 1 ? t[0] : t[1];
			const long double ans = ((a - circ.c) ^ (p - circ.c)) / 2;
			const long double th = (p - circ.c).ang(b - circ.c);
			const long double d = circ.r * circ.r * th / 2;
			if ((a - circ.c).toleft(b - circ.c) == 1)
				return ans + d;
			return ans - d;
		}
		if (!ina && inb)
		{
			const Point p = circ.inter(ab)[0];
			const long double ans = ((p - circ.c) ^ (b - circ.c)) / 2;
			const long double th = (a - circ.c).ang(p - circ.c);
			const long double d = circ.r * circ.r * th / 2;
			if ((a - circ.c).toleft(b - circ.c) == 1)
				return ans + d;
			return ans - d;
		}
		const auto p = circ.inter(ab);
		if (p.size() == 2 && Segment{a, b}.dis(circ.c) <= circ.r + eps)
		{
			const long double ans = ((p[0] - circ.c) ^ (p[1] - circ.c)) / 2;
			const long double th1 = (a - circ.c).ang(p[0] - circ.c), th2 = (b - circ.c).ang(p[1] - circ.c);
			const long double d1 = circ.r * circ.r * th1 / 2, d2 = circ.r * circ.r * th2 / 2;
			if ((a - circ.c).toleft(b - circ.c) == 1)
				return ans + d1 + d2;
			return ans - d1 - d2;
		}
		const long double th = (a - circ.c).ang(b - circ.c);
		if ((a - circ.c).toleft(b - circ.c) == 1)
			return circ.r * circ.r * th / 2;
		return -circ.r * circ.r * th / 2;
	};

	long double ans = 0;
	for (size_t i = 0; i < poly.p.size(); i++)
	{
		const Point a = poly.p[i], b = poly.p[poly.nxt(i)];
		ans += cal(circ, a, b);
	}
	return ans;
}

// 点集的凸包
// Andrew 算法，复杂度 O(nlogn)
Convex convexhull(vector<Point> p)
{
	vector<Point> st;
	if (p.empty())
	{
		Convex ans;
		ans.p = st;
		return ans;
	}
	sort(p.begin(), p.end());
	const auto check = [](const vector<Point> &st, const Point &u)
	{
		const auto back1 = st.back(), back2 = *prev(st.end(), 2);
		return (back1 - back2).toleft(u - back1) <= 0;
	};
	for (const Point &u : p)
	{
		while (st.size() > 1 && check(st, u))
			st.pop_back();
		st.push_back(u);
	}
	size_t k = st.size();
	p.pop_back();
	reverse(p.begin(), p.end());
	for (const Point &u : p)
	{
		while (st.size() > k && check(st, u))
			st.pop_back();
		st.push_back(u);
	}
	st.pop_back();
	Convex ans;
	ans.p = st;
	return ans;
}

// 半平面交
// 排序增量法，复杂度 O(nlogn)
// 输入与返回值都是用直线表示的半平面集合
vector<Line> halfinter(vector<Line> l, const point_t lim = 1e9)
{
	const auto check = [](const Line &a, const Line &b, const Line &c)
	{ return a.toleft(b.inter(c)) < 0; };
	// 无精度误差的方法，但注意取值范围会扩大到三次方
	/*const auto check=[](const Line &a,const Line &b,const Line &c)
	{
		const Point p=a.v*(b.v^c.v),q=b.p*(b.v^c.v)+b.v*(c.v^(b.p-c.p))-a.p*(b.v^c.v);
		return p.toleft(q)<0;
	};*/
	l.push_back({{-lim, 0}, {0, -1}});
	l.push_back({{0, -lim}, {1, 0}});
	l.push_back({{lim, 0}, {0, 1}});
	l.push_back({{0, lim}, {-1, 0}});
	sort(l.begin(), l.end());
	deque<Line> q;
	for (size_t i = 0; i < l.size(); i++)
	{
		if (i > 0 && l[i - 1].v.toleft(l[i].v) == 0 && l[i - 1].v * l[i].v > eps)
			continue;
		while (q.size() > 1 && check(l[i], q.back(), q[q.size() - 2]))
			q.pop_back();
		while (q.size() > 1 && check(l[i], q[0], q[1]))
			q.pop_front();
		if (!q.empty() && q.back().v.toleft(l[i].v) <= 0)
			return vector<Line>();
		q.push_back(l[i]);
	}
	while (q.size() > 1 && check(q[0], q.back(), q[q.size() - 2]))
		q.pop_back();
	while (q.size() > 1 && check(q.back(), q[0], q[1]))
		q.pop_front();
	return vector<Line>(q.begin(), q.end());
}

// 点集形成的最小最大三角形
// 极角序扫描线，复杂度 O(n^2logn)
// 最大三角形问题可以使用凸包与旋转卡壳做到 O(n^2)
pair<point_t, point_t> minmax_triangle(const vector<Point> &vec)
{
	if (vec.size() <= 2)
		return {0, 0};
	vector<pair<int, int>> evt;
	evt.reserve(vec.size() * vec.size());
	point_t maxans = 0, minans = numeric_limits<point_t>::max();
	for (size_t i = 0; i < vec.size(); i++)
	{
		for (size_t j = 0; j < vec.size(); j++)
		{
			if (i == j)
				continue;
			if (vec[i] == vec[j])
				minans = 0;
			else
				evt.push_back({i, j});
		}
	}
	sort(evt.begin(), evt.end(), [&](const pair<int, int> &u, const pair<int, int> &v)
		 {
        const Point du=vec[u.second]-vec[u.first],dv=vec[v.second]-vec[v.first];
        return argcmp()({du.y,-du.x},{dv.y,-dv.x}); });
	vector<size_t> vx(vec.size()), pos(vec.size());
	for (size_t i = 0; i < vec.size(); i++)
		vx[i] = i;
	sort(vx.begin(), vx.end(), [&](int x, int y)
		 { return vec[x] < vec[y]; });
	for (size_t i = 0; i < vx.size(); i++)
		pos[vx[i]] = i;
	for (auto temp : evt)
	{
		auto u = temp.first, v = temp.second;
		const size_t i = pos[u], j = pos[v];
		const size_t l = min(i, j), r = max(i, j);
		const Point vecu = vec[u], vecv = vec[v];
		if (l > 0)
			minans = min(minans, abs((vec[vx[l - 1]] - vecu) ^ (vec[vx[l - 1]] - vecv)));
		if (r < vx.size() - 1)
			minans = min(minans, abs((vec[vx[r + 1]] - vecu) ^ (vec[vx[r + 1]] - vecv)));
		maxans = max({maxans, abs((vec[vx[0]] - vecu) ^ (vec[vx[0]] - vecv)), abs((vec[vx.back()] - vecu) ^ (vec[vx.back()] - vecv))});
		if (i < j)
			swap(vx[i], vx[j]), pos[u] = j, pos[v] = i;
	}
	return {minans, maxans};
}

// 判断多条线段是否有交点
// 扫描线，复杂度 O(nlogn)
bool segs_inter(const vector<Segment> &segs)
{
	if (segs.empty())
		return false;
	using seq_t = tuple<point_t, int, Segment>;
	const auto seqcmp = [](const seq_t &u, const seq_t &v)
	{
		const auto [u0, u1, u2] = u;
		const auto [v0, v1, v2] = v;
		if (abs(u0 - v0) <= eps)
			return make_pair(u1, u2) < make_pair(v1, v2);
		return u0 < v0 - eps;
	};
	vector<seq_t> seq;
	for (auto seg : segs)
	{
		if (seg.a.x > seg.b.x + eps)
			swap(seg.a, seg.b);
		seq.push_back({seg.a.x, 0, seg});
		seq.push_back({seg.b.x, 1, seg});
	}
	sort(seq.begin(), seq.end(), seqcmp);
	point_t x_now;
	auto cmp = [&](const Segment &u, const Segment &v)
	{
		if (abs(u.a.x - u.b.x) <= eps || abs(v.a.x - v.b.x) <= eps)
			return u.a.y < v.a.y - eps;
		return ((x_now - u.a.x) * (u.b.y - u.a.y) + u.a.y * (u.b.x - u.a.x)) * (v.b.x - v.a.x) < ((x_now - v.a.x) * (v.b.y - v.a.y) + v.a.y * (v.b.x - v.a.x)) * (u.b.x - u.a.x) - eps;
	};
	multiset<Segment, decltype(cmp)> s{cmp};
	for (const auto [x, o, seg] : seq)
	{
		x_now = x;
		const auto it = s.lower_bound(seg);
		if (o == 0)
		{
			if (it != s.end() && seg.is_inter(*it))
				return true;
			if (it != s.begin() && seg.is_inter(*prev(it)))
				return true;
			s.insert(seg);
		}
		else
		{
			if (next(it) != s.end() && it != s.begin() && (*prev(it)).is_inter(*next(it)))
				return true;
			s.erase(it);
		}
	}
	return false;
}

// 多边形面积并
// 轮廓积分，复杂度 O(n^2logn)，n为边数
// ans[i] 表示被至少覆盖了 i+1 次的区域的面积
vector<long double> area_union(const vector<Polygon> &polys)
{
	const size_t siz = polys.size();
	vector<vector<pair<Point, Point>>> segs(siz);
	const auto check = [](const Point &u, const Segment &e)
	{ return !((u < e.a && u < e.b) || (u > e.a && u > e.b)); };

	auto cut_edge = [&](const Segment &e, const size_t i)
	{
		const Line le{e.a, e.b - e.a};
		vector<pair<Point, int>> evt;
		evt.push_back({e.a, 0});
		evt.push_back({e.b, 0});
		for (size_t j = 0; j < polys.size(); j++)
		{
			if (i == j)
				continue;
			const auto &pj = polys[j];
			for (size_t k = 0; k < pj.p.size(); k++)
			{
				const Segment s = {pj.p[k], pj.p[pj.nxt(k)]};
				if (le.toleft(s.a) == 0 && le.toleft(s.b) == 0)
				{
					evt.push_back({s.a, 0});
					evt.push_back({s.b, 0});
				}
				else if (s.is_inter(le))
				{
					const Line ls{s.a, s.b - s.a};
					const Point u = le.inter(ls);
					if (le.toleft(s.a) < 0 && le.toleft(s.b) >= 0)
						evt.push_back({u, -1});
					else if (le.toleft(s.a) >= 0 && le.toleft(s.b) < 0)
						evt.push_back({u, 1});
				}
			}
		}
		sort(evt.begin(), evt.end());
		if (e.a > e.b)
			reverse(evt.begin(), evt.end());
		int sum = 0;
		for (size_t i = 0; i < evt.size(); i++)
		{
			sum += evt[i].second;
			const Point u = evt[i].first, v = evt[i + 1].first;
			if (!(u == v) && check(u, e) && check(v, e))
				segs[sum].push_back({u, v});
			if (v == e.b)
				break;
		}
	};

	for (size_t i = 0; i < polys.size(); i++)
	{
		const auto &pi = polys[i];
		for (size_t k = 0; k < pi.p.size(); k++)
		{
			const Segment ei = {pi.p[k], pi.p[pi.nxt(k)]};
			cut_edge(ei, i);
		}
	}
	vector<long double> ans(siz);
	for (size_t i = 0; i < siz; i++)
	{
		long double sum = 0;
		sort(segs[i].begin(), segs[i].end());
		int cnt = 0;
		for (size_t j = 0; j < segs[i].size(); j++)
		{
			if (j > 0 && segs[i][j] == segs[i][j - 1])
				segs[i + (++cnt)].push_back(segs[i][j]);
			else
				cnt = 0, sum += segs[i][j].first ^ segs[i][j].second;
		}
		ans[i] = sum / 2;
	}
	return ans;
}

// 圆面积并
// 轮廓积分，复杂度 O(n^2logn)
// ans[i] 表示被至少覆盖了 i+1 次的区域的面积
vector<long double> area_union(const vector<Circle> &circs)
{
	const size_t siz = circs.size();
	using arc_t = tuple<Point, long double, long double, long double>;
	vector<vector<arc_t>> arcs(siz);
	const auto eq = [](const arc_t &u, const arc_t &v)
	{
		const auto [u1, u2, u3, u4] = u;
		const auto [v1, v2, v3, v4] = v;
		return u1 == v1 && abs(u2 - v2) <= eps && abs(u3 - v3) <= eps && abs(u4 - v4) <= eps;
	};

	auto cut_circ = [&](const Circle &ci, const size_t i)
	{
		vector<pair<long double, int>> evt;
		evt.push_back({-PI, 0});
		evt.push_back({PI, 0});
		int init = 0;
		for (size_t j = 0; j < circs.size(); j++)
		{
			if (i == j)
				continue;
			const Circle &cj = circs[j];
			if (ci.r < cj.r - eps && ci.relation(cj) >= 3)
				init++;
			const auto inters = ci.inter(cj);
			if (inters.size() == 1)
				evt.push_back({atan2l((inters[0] - ci.c).y, (inters[0] - ci.c).x), 0});
			if (inters.size() == 2)
			{
				const Point dl = inters[0] - ci.c, dr = inters[1] - ci.c;
				long double argl = atan2l(dl.y, dl.x), argr = atan2l(dr.y, dr.x);
				if (abs(argl + PI) <= eps)
					argl = PI;
				if (abs(argr + PI) <= eps)
					argr = PI;
				if (argl > argr + eps)
				{
					evt.push_back({argl, 1});
					evt.push_back({PI, -1});
					evt.push_back({-PI, 1});
					evt.push_back({argr, -1});
				}
				else
				{
					evt.push_back({argl, 1});
					evt.push_back({argr, -1});
				}
			}
		}
		sort(evt.begin(), evt.end());
		int sum = init;
		for (size_t i = 0; i < evt.size(); i++)
		{
			sum += evt[i].second;
			if (abs(evt[i].first - evt[i + 1].first) > eps)
				arcs[sum].push_back({ci.c, ci.r, evt[i].first, evt[i + 1].first});
			if (abs(evt[i + 1].first - PI) <= eps)
				break;
		}
	};

	const auto oint = [](const arc_t &arc)
	{
		const auto [cc, cr, l, r] = arc;
		if (abs(r - l - PI - PI) <= eps)
			return 2.0l * PI * cr * cr;
		return cr * cr * (r - l) + cc.x * cr * (sin(r) - sin(l)) - cc.y * cr * (cos(r) - cos(l));
	};

	for (size_t i = 0; i < circs.size(); i++)
	{
		const auto &ci = circs[i];
		cut_circ(ci, i);
	}
	vector<long double> ans(siz);
	for (size_t i = 0; i < siz; i++)
	{
		long double sum = 0;
		sort(arcs[i].begin(), arcs[i].end());
		int cnt = 0;
		for (size_t j = 0; j < arcs[i].size(); j++)
		{
			if (j > 0 && eq(arcs[i][j], arcs[i][j - 1]))
				arcs[i + (++cnt)].push_back(arcs[i][j]);
			else
				cnt = 0, sum += oint(arcs[i][j]);
		}
		ans[i] = sum / 2;
	}
	return ans;
}
```

### 多项式

主要是 NTT。

作者：Kelin。

```cpp
#include <bits/stdc++.h>

using namespace std;
const int N = 1 << 18, pG = 3, P = 998244353; // N = 2 ^ k
using ll = int64_t;

#define inc(a, b) (((a) += (b)) >= P ? (a) -= P : 0)
#define dec(a, b) (((a) -= (b)) < 0 ? (a) += P : 0)
#define mul(a, b) (ll(a) * (b) % P)

int fpow(ll a, int b = P - 2, ll x = 1) {
    for (; b; b >>= 1, a = a * a % P)
        if (b & 1) x = x * a % P;
    return x;
}

int inv[N], fac[N], ifac[N], W[N], _ = [] {
    fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1;
    for (ll i = 2; i < N; ++i) {
        fac[i] = fac[i - 1] * i % P;
        inv[i] = (P - P / i) * inv[P % i] % P;
        ifac[i] = (ll)ifac[i - 1] * inv[i] % P;
    }
    W[N / 2] = 1;
    for (int i = N / 2 + 1, wn = fpow(pG, P / N); i < N; ++i) W[i] = mul(W[i - 1], wn);
    for (int i = N / 2 - 1; ~i; --i) W[i] = W[i << 1];
    return 0;
}();

namespace NTT {
void dft(int *a, int n) {
    for (int k = n >> 1; k; k >>= 1)
        for (int i = 0; i < n; i += k << 1)
            for (int j = 0; j < k; ++j) {
                int &x = a[i + j], y = a[i + j + k];
                a[i + j + k] = mul(x - y + P, W[k + j]);
                inc(x, y);
            }
}
void idft(int *a, int n) {
    for (int k = 1; k < n; k <<= 1)
        for (int i = 0; i < n; i += k << 1)
            for (int j = 0; j < k; ++j) {
                int &x = a[i + j], y = mul(a[i + j + k], W[k + j]);
                a[i + j + k] = x < y ? x - y + P : x - y;
                inc(x, y);
            }
    for (int i = 0, in = P - (P - 1) / n; i < n; ++i)
        a[i] = mul(a[i], in);
    reverse(a + 1, a + n);
}
} // namespace NTT

int norm(int n) { return 1 << (__lg(n - 1) + 1); }

struct Poly : public vector<int> {
#define T (*this)
    using vector<int>::vector;
    int deg() const { return size(); }
    Poly rev() const { return Poly(rbegin(), rend()); }
    void append(const Poly &a) { insert(end(), a.begin(), a.end()); }

    Poly operator-() const {
        Poly a(T);
        for (auto &x : a) x = x ? P - x : 0;
        return a;
    }
    Poly &operator+=(const Poly &a) {
        if (a.deg() > deg()) resize(a.deg());
        for (int i = 0; i < a.deg(); ++i) inc(T[i], a[i]);
        return T;
    }
    Poly &operator-=(const Poly &a) {
        if (a.deg() > deg()) resize(a.deg());
        for (int i = 0; i < a.deg(); ++i) dec(T[i], a[i]);
        return T;
    }
    Poly &operator^=(const Poly &a) {
        if (a.deg() < deg()) resize(a.deg());
        for (int i = 0; i < deg(); ++i) T[i] = mul(T[i], a[i]);
        return T;
    }
    Poly &operator*=(int a) {
        for (auto &x : T) x = mul(x, a);
        return T;
    }

    Poly operator+(const Poly &a) const { return Poly(T) += a; }
    Poly operator-(const Poly &a) const { return Poly(T) -= a; }
    Poly operator^(const Poly &a) const { return Poly(T) ^= a; }
    Poly operator*(int a) const { return Poly(T) *= a; }

    Poly &operator<<=(int k) { return insert(begin(), k, 0), T; }
    Poly operator<<(int r) const { return Poly(T) <<= r; }
    Poly operator>>(int r) const { return r >= deg() ? Poly() : Poly(begin() + r, end()); }
    Poly &operator>>=(int r) { return T = T >> r; }

    Poly pre(int k) const { return k < deg() ? Poly(begin(), begin() + k) : T; }
    friend void dft(Poly &a) { NTT::dft(a.data(), a.size()); }
    friend void idft(Poly &a) { NTT::idft(a.data(), a.size()); }
    friend Poly conv(Poly a, Poly b, int n) {
        a.resize(n), dft(a);
        b.resize(n), dft(b);
        return idft(a ^= b), a;
    }
    Poly operator*(const Poly &a) const {
        int n = deg() + a.deg() - 1;
        return conv(T, a, norm(n)).pre(n);
    }
    // Description: f_i = sum T_{i + j} * a_j
    Poly mulT(const Poly& a) const { return T * a.rev() >> (a.deg() - 1); }

    /*
     * Description: Calculate f_1, ..., f_{n - 1} with a_i = sum_{j > 0} f_{i - j} g_j
     *    and f_i = F(a_i, i),where g and f_0 is known, notice T_i = g_{i + 1}.
     * Time: O(n log^2 n)
     */
    template <typename func>
    Poly semiConv(Poly f, int n, func calc) {
        f.resize(n);
        vector<Poly> va(n); // storage dft result, faster
        for (int m = 1; m < n; m++) {
            int k = m & -m, l = m - k, r = min(m + k, n);
            Poly &p = va[k], q(f.begin() + l, f.begin() + m);
            if (p.empty()) p = pre(r - l - 1), p.resize(k * 2), dft(p);
            q.resize(k << 1), dft(q), idft(q ^= p);
            // Poly q = conv(Poly(f.begin() + l, f.begin() + m), pre(r - l - 1), k << 1);
            for (int i = m; i < r; i++) inc(f[i], q[i - l - 1]);
            calc(f, m);
        }
        return f;
    }
    Poly inv2(int n) const {
        int i0 = fpow(T[0]);
        return (T >> 1).semiConv({i0}, n, [&](Poly &f, int m) { f[m] = mul(f[m], P - i0); });
    }
    Poly exp2(int n) const { return deriv().semiConv({1}, n, [&](Poly &f, int m) { f[m] = mul(f[m], ::inv[m]); }); }

    Poly inv(int n) const {
        Poly x{fpow(T[0])};
        for (int k = 1; k < n; k <<= 1)
            x.append(-((conv(pre(k << 1), x, k << 1) >> k) * x).pre(k));
        return x.pre(n);
    }
    Poly deriv() const {
        if (empty()) return {};
        Poly a(deg() - 1);
        for (ll i = 1; i < deg(); ++i) a[i - 1] = i * T[i] % P;
        return a;
    }
    Poly integ() const {
        if (empty()) return {};
        Poly a(deg() + 1);
        for (int i = 1; i <= deg(); ++i) a[i] = mul(::inv[i], T[i - 1]);
        return a;
    }
    Poly log(int n) const { return (deriv() * inv(n)).integ().pre(n); }
    Poly exp(int n) const {
        Poly x{1};
        for (int k = 1; k < n; k <<= 1)
            x.append((x * ((pre(k << 1) - x.log(k << 1)) >> k)).pre(k));
        return x.pre(n);
    }
    Poly pow(int k, int n) const { return (log(n) * k).exp(n); } // T[0] = 1
    Poly pow(int k, int kp, int n) const { // k = K % P, kp = K % phi(P)
        int i = 0;
        while (i < deg() && !T[i]) i++;
        if (1ll * i * k >= n) return Poly(n);
        int v = T[i], m = n - i * k;
        return ((((T >> i) * fpow(v)).log(m) * k).exp(m) << (i * k)) * fpow(v, kp);
    }
    Poly sqrt(int n) const {
        Poly x{1}, y{1}; // x[0] = sqrt(T[0]), default T[0] = 1
        for (int k = 1; k < n; k <<= 1) {
            x.append((((pre(k << 1) - x * x) >> k) * y).pre(k) * ((P + 1) >> 1));
            k << 1 < n ? y.append(-((conv(x.pre(k << 1), y, k << 1) >> k) * y).pre(k)) : void();
        }
        return x.pre(n);
    }
    vector<Poly> operator/(const Poly &a) const {
        int k = deg() - a.deg() + 1;
        if (k < 0) return {{0}, T};
        Poly q = (rev().pre(k) * (a.rev().inv(k))).pre(k).rev(), r = T - a * q;
        return {q, r.pre(a.deg() - 1)};
    }

    /*
     * Description: calculate [x ^ k](f / g)
     * Time: O(n log n log k)
     */
    int divAt(Poly f, Poly g, ll k) {
        int n = max(f.deg(), g.deg()), m = norm(n);
        for (; k; k >>= 1) {
            f.resize(m * 2), dft(f);
            g.resize(m * 2), dft(g);
            for (int i = 0; i < 2 * m; ++i) f[i] = mul(f[i], g[i ^ 1]);
            for (int i = 0; i < m; ++i) g[i] = mul(g[2 * i], g[2 * i + 1]);
            g.resize(m), idft(f), idft(g);
            for (int i = 0, j = k & 1; i < n; i++, j += 2) f[i] = f[j];
            f.resize(n), g.resize(n);
        }
        return f[0];
    }

    /*
     * Description: calculate T[k], where T[n] = sum c[i] * T[n - i]
     * Time: O(n log n log k)
     */
    int recur(Poly c, ll k) { return c[0] = P - 1, divAt((T * c).pre(c.deg() - 1), c, k); }

    /*
     * Description: polynomial multipoint fast evaluation
     * Time: O(n log^2 n)
     */
    Poly eval(Poly x) const {
        if (empty()) return Poly(x.deg());
        const int m = x.deg(), n = norm(m);
        vector<Poly> q(2 * n, {1});
        Poly ans(m), temp, d(2 * n);
        for (int i = n; i < n + m; ++i) q[i] = Poly{1, P - x[i - n]};
        for (int i = n - 1; i; --i) q[i] = q[i << 1] * q[i << 1 | 1];
        q[1] = mulT(q[1].inv(n));
        for (int i = 1, l = 2, r = 3; i < n; ++i, l += 2, r += 2) {
            temp = q[l], d[l] = d[r] = d[i] + 1;
            q[l] = q[i].mulT(q[r]).pre(n >> d[l]);
            q[r] = q[i].mulT(temp).pre(n >> d[r]);
        }
        for (int i = n; i < n + m; ++i) ans[i - n] = q[i][0];
        return ans;
    }

#undef T
};

// useless algorithm
/*
 * Description: G(F(x))
 * Time: O(n sqrt n log n + n ^ 2)
 */
Poly compound(Poly f, Poly g) {
    int n = f.size(), k = norm(2 * n), L = sqrt(n) + 1;
    vector<Poly> G(L + 1);
    Poly H, h(k), t; // H = g ^ (iL)
    auto dft = [&](Poly &a) { a.resize(k), NTT::dft(a.data(), k); };
    auto idft = [&](Poly &a) { NTT::idft(a.data(), k), a.resize(n); };
    G[0] = H = {1}, dft(g);
    for (int i = 1; i <= L; ++i) dft(G[i] = G[i - 1]), idft(G[i] ^= g);
    dft(g = G[L]);
    for (int i = 0; i < L; ++i, t = {}, idft(H)) {
        for (int j = 0; j < min(L, n - i * L); ++j) t += G[j] * f[i * L + j];
        dft(t), dft(H);
        for (int j = 0; j < k; ++j) h[j] = (h[j] + (ll)t[j] * H[j]) % P, H[j] = mul(H[j], g[j]);
    }
    return idft(h), h;
}

/*
 * Description: get F(x) for F(G(x)) = x
 * Time: O(n sqrt n log n + n ^ 2)
 */
Poly compoundInv(Poly g) { // 
    int n = g.size(), k = norm(2 * n), L = sqrt(n) + 1;
    vector<Poly> G(L + 1);
    Poly H, f(n);
    auto dft = [&](Poly &a) { a.resize(k), NTT::dft(a.data(), k); };
    auto idft = [&](Poly &a) { NTT::idft(a.data(), k), a.resize(n); };
    G[0] = H = {1}, H.resize(n), dft(g = (g >> 1).inv(n));
    for (int i = 1; i <= L; ++i) dft(G[i] = G[i - 1]), idft(G[i] ^= g);
    dft(g = G[L]);
    for (int i = 0, t = 1; i < L; ++i) {
        for (int j = 1; j <= L && t < n; ++j, ++t)
            for (int r = 0; r < t; ++r) f[t] = (f[t] + (ll)G[j][r] * H[t - 1 - r]) % P;
        dft(H), idft(H ^= g);
    }
    return f ^ Poly(inv, inv + N);
}
```

### 字符串

作者：懵哥（walk_alone）。

#### 后缀自动机

```cpp
class SAM
{
    const int shift = 97;
    struct node
    {
        int ch[26];
        int len;
        int father;
        long long cnt;
        node()
        {
            memset(ch, 0, sizeof(ch));
            len = father = cnt = 0;
        }
    } NIL;
    vector<node> t;
    int last, ind;
    void insert(int c)
    {
        int p = last;
        int np = last = ++ind;
        t.push_back(NIL);
        t[np].len = t[p].len + 1;
        t[np].cnt = 1;
        for (; p && !t[p].ch[c]; p = t[p].father)
            t[p].ch[c] = np;
        if(!p)
            t[np].father = 1;
        else
        {
            int q = t[p].ch[c];
            if (t[p].len + 1 == t[q].len)
                t[np].father = q;
            else
            {
                int nq = ++ind;
                t.push_back(t[q]);
                t[nq].cnt = 0;
                t[nq].len = t[p].len + 1;
                t[q].father = t[np].father = nq;
                for (; p && t[p].ch[c] == q; p = t[p].father)
                    t[p].ch[c] = nq;
            }
        }
        /*广义SAM打标记
        for (; np && col[np] != color; np = father[np])
        {
            col[np] = color;
            times[np]++;
        }
        */
    }
 
public:
    SAM(string s)
    {
        last = ind = 1;
        t.push_back(NIL);
        t.push_back(NIL);
        for (auto i : s)
            insert(i - shift);
        vector<vector<int>> graph(t.size());
        for (int i = 2; i <= ind;i++)
            graph[t[i].father].push_back(i);
        function<void(int)> dfs = [&](int place)
        {
            for (auto i : graph[place])
            {
                dfs(i);
                t[place].cnt += t[i].cnt;
            }
        };
        dfs(1);
    }
};
```



#### SA

```cpp
class SA
{
    vector<int> sa_doubling(vector<int> &s)
    {
        int n = int(s.size());
        vector<int> sa(n), rnk = s, tmp(n);
        iota(sa.begin(), sa.end(), 0);
        for (int k = 1; k < n; k *= 2)
        {
            auto cmp = [&](int x, int y)
            {
                if (rnk[x] != rnk[y])
                    return rnk[x] < rnk[y];
                int rx = x + k < n ? rnk[x + k] : -1;
                int ry = y + k < n ? rnk[y + k] : -1;
                return rx < ry;
            };
            sort(sa.begin(), sa.end(), cmp);
            tmp[sa[0]] = 0;
            for (int i = 1; i < n; i++)
                tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);
            swap(tmp, rnk);
        }
        return sa;
    }
    template <class T>
    vector<int> suffix_array(vector<T> &s)
    {
        int n = int(s.size());
        std::vector<int> idx(n);
        iota(idx.begin(), idx.end(), 0);
        sort(idx.begin(), idx.end(), [&](int l, int r)
             { return s[l] < s[r]; });
        std::vector<int> s2(n);
        int now = 0;
        for (int i = 0; i < n; i++)
        {
            if (i && s[idx[i - 1]] != s[idx[i]])
                now++;
            s2[idx[i]] = now;
        }
        return sa_doubling(s2);
    }
    template <class T>
    vector<int> lcp_array(vector<T> &s, vector<int> &sa)
    {
        int n = int(s.size());
        assert(n >= 1);
        std::vector<int> rnk(n);
        for (int i = 0; i < n; i++)
            rnk[sa[i]] = i;
        std::vector<int> lcp(n - 1);
        int h = 0;
        for (int i = 0; i < n; i++)
        {
            if (h > 0)
                h--;
            if (rnk[i] == 0)
                continue;
            int j = sa[rnk[i] - 1];
            for (; j + h < n && i + h < n; h++)
                if (s[j + h] != s[i + h])
                    break;

            lcp[rnk[i] - 1] = h;
        }
        return lcp;
    }

public:
    vector<int> suffix_array(string s)
    {
        int n = int(s.size());
        vector<int> s2(n);
        for (int i = 0; i < n; i++)
            s2[i] = s[i];
        return sa_doubling(s2);
    }
    vector<int> lcp_array(string s, vector<int> sa)
    {
        int n = int(s.size());
        vector<int> s2(n);
        for (int i = 0; i < n; i++)
            s2[i] = s[i];
        return lcp_array(s2, sa);
    }
};
```



#### PAM

```cpp
class PAM
{
    struct node
    {
        int mask;
        int ch[26];
        int fail;
        int len;
        long long cnt;
        node ()
        {
            memset(ch, 0, sizeof(ch));
            fail = len = cnt = 0;
        }
    };
    vector<node> t;
    int tot, len, last;
    string s;
    int getfail(int x,int place)
    {
        while (s[place - t[x].len - 1] != s[place])
            x = t[x].fail;
        return x;
    }
    int newnode(int x)
    {
        node temp = *new node;
        temp.len = x;
        temp.mask = 0;
        t.push_back(temp);
        return ++tot;
    }
 
public:
    PAM(string s)
    {
        int n = s.length();
        this->len = n;
        this->last = 0;
        s = "$" + s;
        this->s = s;
        this->tot = 1;
        this->t.push_back(*new node);
        this->t.push_back(*new node);
        t[0].mask = t[1].mask = 0;
        t[0].len = 0;
        t[0].fail = 1;
        t[1].len = -1;
        for (int i = 1; i <= n;i++)
        {
            int p = getfail(last, i);
            if (!t[p].ch[s[i] - 97])
            {
                int q = newnode(t[p].len + 2);
                t[q].fail = t[getfail(t[p].fail, i)].ch[s[i] - 97];
                t[q].mask = t[p].mask | (1 << (s[i] - 97));
                t[p].ch[s[i] - 97] = q;
            }
            last = t[p].ch[s[i] - 97];
            t[last].cnt++;
        }
        for (int i = tot; i >= 2; i--)
            if (t[i].fail > 1)
                t[t[i].fail].cnt += t[i].cnt;
    }
};
```

#### ACAM

```cpp
class ACAM
{
private:
    struct node
    {
        int ed;
        int fail;
        int ch[26];
        node()
        {
            ed = fail = 0;
            memset(ch, 0, sizeof(ch));
        }
    } NIL;
    int siz = 0;
    vector<node> tr;
 
public:
    ACAM()
    {
        tr.push_back(NIL);
    }
    void insert(string s)
    {
        int place = 0;
        for (int i = 0; i < s.length();i++)
        {
            if (tr[place].ch[s[i] - 65] == 0)
            {
                tr[place].ch[s[i] - 65] = ++siz;
                tr.push_back(NIL);
            }
            place = tr[place].ch[s[i] - 65];
        }
        tr[place].ed = 1;
    }
    void build()//一定要build
    {
        queue<int> q;
        for (int i = 0; i < 26;i++)
            if(tr[0].ch[i])
                q.push(tr[0].ch[i]);
        while(!q.empty())
        {
            int tp = q.front();
            tr[tp].ed |= tr[tr[tp].fail].ed;
            q.pop();
            for (int i = 0; i < 26;i++)
                if(tr[tp].ch[i])
                {
                    tr[tr[tp].ch[i]].fail = tr[tr[tp].fail].ch[i];
                    q.push(tr[tp].ch[i]);
                }
                else
                    tr[tp].ch[i] = tr[tr[tp].fail].ch[i];
        }
    }
};
```



#### Manacher

```cpp
class Manacher
{
	vector<int> hw;
	string a;

public:
	Manacher(string a)
	{
		this->a = a;
		string b = "$|";
		for (auto i : a)
		{
			b += i;
			b += '|';
		}
		int len = b.length();
		hw.resize(b.length());
		int maxright = 1, mid = 1;
		for (int i = 1; i < len; i++)
		{
			if (i < maxright)
				hw[i] = min(hw[mid * 2 - i], hw[mid] + mid - i);
			else
				hw[i] = 1;
			while (b[i - hw[i]] == b[i + hw[i]])//匹配过程
				hw[i]++;
			if (i + hw[i] > maxright)
			{
				maxright = i + hw[i];
				mid = i;
			}
		}
	}
};
```



#### KMP

```cpp
class KMP
{
	vector<int> nx;
	string b;

public:
	KMP(string b)
	{
         this->b = b;
		int n = b.length();
		int j = 0;
		nx.resize(n);
		for (int i = 1; i < n; i++)
		{
			while (j > 0 && b[i] != b[j])
				j = nx[j - 1];
			if (b[i] == b[j])
				j++;
			nx[i] = j;
    	}
	}
	int find(string &a)
	{
		int n = b.length(), m = a.length();
		int j = 0;
		long long ans = 0;
		for (int i = 0; i < m; i++)
		{
			while (j > 0 && a[i] != b[j])
				j = nx[j - 1];
			if (a[i] == b[j])
				j++;
			if (j == n)
			{
				//匹配位点:i-n+1
				ans++;
				j = nx[j - 1];
			}
    	}
    	return ans;
	}
};
```



#### Z 函数

```cpp
class Z_function
{
    vector<int> z;
    string b;

public:
    Z_function(string b) //模式串
    {
        this->b = b;
        int n = b.length();
        z.resize(n);
        z[0] = n;
        int left = -1, right = -1;
        for (int i = 1; i < n; i++)
        {
            if (i <= right)
                z[i] = min(z[i - left], right - i);
            while (i + z[i] < n && b[z[i]] == b[z[i] + i]) //匹配过程
                z[i]++;
            if (i + z[i] - 1 > right)
            {
                left = i;
                right = i + z[i] - 1;
            }
        }
    }
    vector<int> get_lcp(string a)//求b与a的每个后缀的lcp
    {
        int left = -1, right = -1, n = a.length();
        vector<int> lcp(n);
        for (int i = 0; i < n; i++)
        {
            if (i <= right)
                lcp[i] = min(z[i - left], right - i);
            while (i + lcp[i] < n && lcp[i] < b.length() && b[lcp[i]] == a[i + lcp[i]]) 
                lcp[i]++;//匹配过程
            if (i + lcp[i] - 1 > right)
            {
                left = i;
                right = i + lcp[i] - 1;
            }
        }
        return lcp;
    }
};
```



#### Lyndon 分解

```cpp
vector<string> duval(string const &s)//返回各Lyndon串
{
    int n = s.size(), i = 0;
    vector<string> factorization;
    while (i < n)
    {
        int j = i + 1, k = i;
        while (j < n && s[k] <= s[j])
        {
            if (s[k] < s[j])
                k = i;
            else
                k++;
            j++;
        }
        while (i <= k)
        {
            factorization.push_back(s.substr(i, j - k));
            i += j - k;
        }
    }
    return factorization;
}
string min_cyclic_string(string s) //最小表示法
{
    s += s;
    int n = s.size();
    int i = 0, ans = 0;
    while (i < n / 2)
    {
        ans = i;
        int j = i + 1, k = i;
        while (j < n && s[k] <= s[j])
        {
            if (s[k] < s[j])
                k = i;
            else
                k++;
            j++;
        }
        while (i <= k)
            i += j - k;
    }
    return s.substr(ans, n / 2);
}
```



#### Hash

```cpp
class myhash
{
    long long mod;
    vector<long long> th, invth;
    vector<long long> h;
    long long power(long long a, long long x)
    {
        long long ans = 1;
        while(x)
        {
            if (x & 1)
                ans = ans * a % mod;
            a = a * a % mod;
            x >>= 1;
        }
        return ans;
    }
    long long inv(long long a)
    {
        return power(a, mod - 2);
    }
 
public:
    myhash(long long _mod, long long _base, string &s)
    {
        mod = _mod;
        int n = s.length();
        th.resize(n);
        invth.resize(n);
        h.resize(n);
        th[0] = invth[0] = 1;
        for (int i = 1; i < n;i++)
            th[i] = th[i - 1] * _base % mod;
        invth[n - 1] = inv(th[n - 1]);
        for (int i = n - 2; i >= 0;i--)
            invth[i] = invth[i + 1] * _base % mod;
        for (int i = 0; i < n; i++)
        {
            h[i] = (s[i] - 97) * th[i] % mod;
            if(i)
                h[i] = (h[i] + h[i - 1]) % mod;
        }
    }
    long long get_val(int l, int r)
    {
        if (l > r)
            return -1;
        long long ans = h[r];
        if (l)
            ans = (ans - h[l - 1] + mod) % mod * invth[l] % mod;
        return ans;
    }
    bool check(int l1, int r1, int l2, int r2)
    {
        auto a = get_val(l1, r1), b = get_val(l2, r2);
        if (a == -1 || b == -1)
            return false;
        return a == b;
    }
};
```



#### 关闭同步流

```cpp
	cin.tie(0)->sync_with_stdio(0);
	cin.exceptions(cin.failbit);
	cin.tie(NULL);
	cout.tie(NULL);
```

